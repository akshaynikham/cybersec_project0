Shell?1. When we speak of the command line, we are really referring to the shell.2. The shell is a program that takes keyboard commands and passes them to the operating system to carry out.3. Almost all Linux distributions supply a shell program from the GNU Project called bash.Terminal Emulators?When using a graphical user interface (GUI), we need another program called terminal emulators to interact with the SHELL.KDE uses konsole and GNOME uses gnome-terminal, it's likely called simply "terminal" on our menu.Navigation1. pwd ----Manipulating Files and Directories---- Wildcards: shell feature. using wildcards, also known as globbing. 	- helps to select filenames based on characters. 	- Wildcard table: 		- * --> matches any characters. 		- ? --> matches a single characters. 		- [characters] --> matches any character that is a member of set characters. 		- [!characters] or [^characters] --> Matches any character that is not a member of the set characters. 		- [[:class:]] --> Matches any characters that is a member of the specified class. 	- commonly used character classes 		- [:alnum:] --> Matches any alphanumerical characters. 		- [:alpha:] --> Matches any alphabetic character. 		- [:digit:] --> Matches any numeral 		- [:lower:] --> Matches any lowercase letter. 		- [:upper:] --> Matched any uppercase letter.---- mkdir: Create directories.---- cp: Copy files and directories. 	- cp can be used in 2 different ways. 		- cp item1 or item2 --> copy file or directory item1 to the file or directory item2 		- cp item... directory --> copies multiple items (either files or directories) into a directory. 	- Useful cp options. 		- -a --archive  	Copy the files and directories and all of their attributes, including ownerships and 					permissions. Normally, copies take on the default attributes of the user performing the 					copy. 		- -i --interactive 	Before overwriting the existing file, prompt the user for confirmation. 		- -r --recursive 	Recursively copy directories and their contents. This option (or the -a option) is required when 					copying directories. 		- -u --update 		When copying files from one directory to another, only copy files that either don't exist or 					are newer than the existing corresponding files, in the destination directory. This is useful when 					copying large numbers of files as it skips files that don't need to be copied. 		- -v --verbose 		Display informative messages as the copy is performed.---- mv: move and rename files. 	- Move performs both file moving and file renaming. 	- mv can be used in 2 different ways. 		- mv item1 or item2 --> move file or directory item1 to the file or directory item2 		- mv item... directory --> move multiple items (either files or directories) into directory. 	- Useful cp options. 	- **-i --interactive** 	Before overwriting an existing file, prompt the user for confirmation. If this option is not 					specified, mv will silently overwrite files. 		- -u --update 		When moving files from one directory to another, only move files that either don't exist, 					or are newer than the existing corresponding files in the destination directory. 		- -v --verbose 		Display informative messages as the move is performed.---- rm: Remove Files and Directories. 	- The rm command is used to remove (delete) files and directories 	- rm item... --> where item is one or more directory.  	- Useful cp options. 		-i --interactive 	Before deleting an existing file, prompt the user for confirmation. If this option is not specified, 					rm will silently delete files. 		-r --recursive 		Recursively delete directories. This means that if a directory being deleted has subdirectories, 					delete them too. To delete a directory, this option must be specified. 		-f --force 		Ignore nonexistent files and do not prompt. This overrides the --interactive option. 		-v --verbose 		Display informative messages as the deletion is performed.---- ln: Create links 	- this command is used to create either hard or symbolic links. 	- it is used in two ways 		- ln file link --> this create a hard link. 		- ln -s item link --> this creates a symbolic link where item is either file or directory. 	- Hard links: 		- Original way of creating links, compared to symbolic links, which are more modern. 		- In Linux/Unix file systems (like ext4, XFS, etc.), files are not stored directly by their names. 		- A file actually consists of data blocks (the contents of the file) and an inode (a data structure that stores metadata like file size, permissions, and pointers to data 			blocks). 		- A hard link is basically a directory entry that maps a file name to an inode. 		- By default, every file has a single hard link that gives the file its name. 		- Hard links have two important limitations: 			1.	A hard link cannot reference a file outside its own file system. This means a link 				cannot reference a file that is not on the same disk partition as the link itself. 			2. 	A hard link may not reference a directory. 	- Symbolic links: 		- Symbolic links were created to overcome the limitations of hard links. 		- Symbolic links work by creating a special type of file that contains a text pointer to the referenced file or directory. 		- In this regard, they operate in much the same way as a Windows shortcut, though of course they predate the Windows feature by many years. ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Working with Commands -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------What Exactly Are Commands? 	- An executable program: like all those files in /usr/bin. 	- A command built into the shell itself: Bash supports a number of commands internally called shell built-ins. 	- A shell function: Shell functions are miniature shell scripts incorporated into the environment. 	- An alias: Aliases are commands that we can define ourselves, built from other commands.---Identifying commands.--- 	- It is often useful to know exactly which of the four kinds of commands is being used and Linux provides a couple of ways to find out. 	- type: Display a Command's Type 		- The shell builtin that displays the kind of command the shell will execute, given a particular command once. 		- It works like this: type command --> "command" is the command we want to examine. 	- which: Display an Executable's Location 		- Sometimes there is more than one version of an executable program installed on a system. To determine the exact location of a given executable, 		  the which command is used. 		- ex: 	[me@linuxbox ~]$ which ls 			/usr/bin/ls 		- Imp: which only for executable programs, not bulletins nor alias that are substitutes for actual executable programs.---Getting the command's Documentation--- 	- help: get help for shell builtins 		- bash has built-in facility available for each of the shell builtins. 		- ex: 	[me@linuxbox ~]$ help cd 			cd: cd [-L|[-P [-e]] [-@]] [dir] 			Change the shell working directory. 			Change the current directory to DIR. The default DIR is the 			value of the HOME shell variable. 			The variable CDPATH defines the search path for the directory 			containing DIR. Alternative directory names in CDPATH are 			separated by a colon (:). A null directory name is the same as 			the current directory. If DIR begins with a slash (/), then 			CDPATH is not used. 			If the directory is not found, and the shell option `cdable_vars' 			is set, the word is assumed to be a variable name. If that 			variable has a value, its value is used for DIR. 			Options: 				-L force symbolic links to be followed: resolve symbolic 				links in DIR after processing instances of `..' 				-P use the physical directory structure without following 				symbolic links: resolve symbolic links in DIR before 				processing instances of `..' 				-e if the -P option is supplied, and the current working 				directory cannot be determined successfully, exit with 				a non-zero status 				-@ on systems that support it, present a file with extended 				 attributes as a directory containing the file attributes 				 The default is to follow symbolic links, as if `-L' were 				 specified. `..' is processed by removing the immediately previous 				 pathname component back to a slash or the beginning of DIR. 				 Exit Status: 					 Returns 0 if the directory is changed, and if $PWD is set 					 successfully when -P is used; non-zero otherwise. 		- A note on notation:   When square brackets appear in the description of a command's syntax, 					they indicate optional items. A vertical bar character indicates mutually exclusive 					items. 					In the case of the cd command above: cd [-L|[-P[-e]]] [dir] 					This notation says that the command cd may be followed optionally by either a “-L” or a 					“-P” and further, if the “-P” option is specified the “-e” option may also be included followed by the optional argument “dir”. 	- --help -> Display usage information 		    Many executable program support "--help" option that displays a description of the command's supported syntax and options. 		    -ex: [me@linuxbox ~]$ mkdir --help 	- man -> Display a program's Manual Page. 		- Most executable program intended for command line use provide a formal piece of documentation called manual or man page. 		- A special paging program called man is used to view them. 		- syntax: man program 	- apropos -> Display Appropriate commands. 			- it is possible to search the list of man pages for possible matches based on a search item. 			- ex: 	[me@linuxbox ~]$ apropos partition 				output -> addpart(8) 		- simple wrapper around the "add partition"... 				explanation -> first field is the name of the man page, second field shows the section. 			- Note: man command the "-k" option performs the same function as apropos. 	- whatis -> Display one-line manual page description. 			- whatis program displays the name and a one-line description of a man page matching a specific keyword. 			- ex: 	[me@linuxbox ~]$ whatis ls 				ls (1) - list directory contents  	- info -> The GNU Project provides an alternative to man pages for their programs, called “info.” 		  Info manuals are displayed with a reader program named, appropriately enough, info. 		  Info pages are hyperlinked much like web pages.---- Creating our own command---- 	- syntax: alias name='string'	- After the command alias, we give alias a name followed immediately (no whitespace	  allowed) by an equal sign, followed immediately by a quoted string containing the meaning to be assigned to the name.	- Ex: [me@linuxbox ~]$ alias foo='cd /usr; ls; cd -'	- To remove an alias, the unalias command is used, like so: [me@linuxbox ~]$ unalias foo	- To see all the aliases defined in the environment, use the alias command without arguments.----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Redirection ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Introduce the following commands,1. cat - concatenate files2. sort - sort lines of text3. uniq - Report or omit repeated lines4. grep - Print lines matching a pattern5. wc - print newline, word and byte counts for each file6. head - Output the first part of a file7. tail - output the last part of a file8. tee - Read from standard input and write to standard output and files---Standard input, output and error---	- Keeping with the unix theme that "everything is a file" programs such as ls send their results to a special file called standard output (often expressed as stdout)	  and their status message to standard error (stderr).	- By default, both stdout and stderr are linked to screen and not saved to file.	- many programs take input from a facility called standard input (stdin), which is by default attached to the keyboard.	- Standard error messages are sent to standard error ( stderr ).	- with I/O redirection we can change where the input comes and output goes.---Redirecting the standard output---	- To redirect standard output to another file instead of the screen, we use > redirection operator followed by the name of the file.	- Ex: [me@linuxbox ~]$ ls -l /usr/bin > ls-output.txt	- Note: when redirect operator is used ">" the destination file always overwritten.	- To redirect output without overwriting the file we need to use ">>" 	- Ex: [me@linuxbox ~]$ ls -l /usr/bin >> ls-output.txt---Group Commands---	- Scenario: imagine a situation where we want to execute a series of commands and send the results to a log file. 	- we can try this [me@linuxbox ~]$ command1; command2; command3	- Ex: [me@linuxbox ~]$ command1 > logfile.txt; command2 >> logfile.txt; command3 >> logfile.txt	- but we can also do this by creating a group command: [me@linuxbox ~]$ { command1; command2; command3; } > logfile.txt---Redirecting Standard Error---	- Redirecting standard error lacks the ease of a dedicated redirection operator.	- we referred first three file stream as standard input, output and error, the shell refer to them internally as file descriptor 0,1,2 respectively.	- shell provides a notation for redirecting file using file descriptor.	- since standard error is same as file descriptor number 2, we can redirect standard error as with the notation as 		[me@linuxbox ~]$ ls -l /bin/usr 2> ls-error.txt				---Redirecting standard output and standard error to one file---	- there are two ways to do it: 		1. [me@linuxbox ~]$ ls -l /bin/usr > ls-output.txt 2>&1		2. [me@linuxbox ~]$ ls -l /bin/usr &> ls-output.txt	- We can also append the standard output and standard error streams to a single file like so:		[me@linuxbox ~]$ ls -l /bin/usr &>> ls-output.txt---Disposing of unwanted output---	- We can throw away the output to a special file called "dev/null"	- the file is a system device often referred to as bit bucket, which accepts input and does nothing with it.---Redirecting the standard input---		cat - concatenate files	-----------------------	- the cat command reads one or more files and copies them to standard output like: cat [file...]	- cat is often used to display short files.	- since cat accepts more than one file as an argument, it can also be used to join files together.	- if cat is not given any arguments, it reads from standard input and since standard input is by default attached to the keyboard, 	  it will wait for user input. ctl-d to tell cat it has reached end of the file.	- cat copies standard input to standard output, this behaviour can be used to create short text files.	- Ex: 	[me@linuxbox ~]$ cat > lazy_dog.txt		The quick brown fox jumps over the lazy dog.	- In the above example, cat will accept the user input and place the input into the file. If the file does not exists the > operator will create one.	- To see our results, we can use cat to copy the file to stdout again.	- Ex: 	[me@linuxbox ~]$ cat lazy_dog.txt		The quick brown fox jumps over the lazy dog.	- we can redirecting standard input to cat as shown: 		[me@linuxbox ~]$ cat < lazy_dog.txt 		The quick brown fox jumps over the lazy dog.	- Using the "<" redirection operator we can change the source from standard input from the keyboard to the file lazy_dog.txt	Pipeline	-----------------------	- The capability of commands to read data from standard input and send to standard output is utilized by a shell feature called pipelines.	- Using the pipe operator | (vertical bar), the standard output of one command can be piped into standard input of another.	- command1 | command2		Filters		-----------------------		- Sort		Uniq - report or Omit repeated lines		-----------------------		- The uniq command is used in conjunction with sort.		- uniq accepts a sorted list of data either from standard input or a single filename argument and by default removes any duplicates from the list.		- Ex: [me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | less		- If we want to see the list of duplicates instead, we add the “-d” option to uniq like so:		- Ex: [me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq -d | less		wc - Print line, word and byte count		-----------------------		- The wc (word count) command is used to display the number of lines, words, and bytes contained in a files.		- Ex: 	[me@linuxbox ~]$ wc ls-output.txt 			7902 64566 503634 ls-output		- it prints lines, count and byte counts		- Like previous commands, if executed without a command line arguments, wc accepts standard input.		grep - Print lines matching a pattern		-----------------------		- grep is a powerful program used to find text pattern within the files. It's used like this,		- syntax: grep pattern [file...]		- when grep encounters a "pattern" in the file, it prints out the lines containing it.		- Ex: 	[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | grep zip			bunzip2			bzip2			gunzip			gzip			unzip			zip			zipcloak			zipgrep			zipinfo			zipnote			zipsplit		- few handy options for grep			-i, causes grep to ignore case when performing the search			-l, causes grep to only output the names of the files containing text that matches the pattern.			-v, causes grep to print only lines that do not match the pattern.			-w, caused grep to only match whole words. 		head/tail - Print First/Last Part of files		-----------------------		- head prints the first ten lines and tails command prints the last ten lines.		- Ex:	[me@linuxbox ~]$ head -n 5 ls-output.txt			total 343496			-rwxr-xr-x 1 root root 31316 2007-12-05 08:58 [			-rwxr-xr-x 1 root root 8240 2007-12-09 13:39 411toppm			-rwxr-xr-x 1 root root 111276 2007-11-26 14:27 a2p			-rwxr-xr-x 1 root root 25368 2006-10-06 20:16 a52dec			[me@linuxbox ~]$ tail -n 5 ls-output.txt			-rwxr-xr-x 1 root root 5234 2007-06-27 10:56 znew			-rwxr-xr-x 1 root root 691 2005-09-10 04:21 zonetab2pot.py			-rw-r--r-- 1 root root 930 2007-11-01 12:23 zonetab2pot.pyc			-rw-r--r-- 1 root root 930 2007-11-01 12:23 zonetab2pot.pyo			lrwxrwxrwx 1 root root 6 2016-01-31 05:22 zsoelim -> soelims				- These commands can be used in pipelines as well:		- Ex: [me@linuxbox ~]$ ls /usr/bin | tail -n 5		- "-n" options with head and tail allow us to cut an excerpt from the middle of the file.		- The -n option when used with head allows a negative value which causes all but the last n lines to be output. 			Similarly, the -n option with tail allows a plus sign causing all but the first n lines to be output. 				tee - Read from Stdin and Output to Stdout and Files		-----------------------		- Linux provides a command called tee which creates a "tee" fitting on our pipe.		- The tee program reads standard input and copies to standard out ( allowing the data to continue down the pipeline) and to one or more files.		- Ex: [me@linuxbox ~]$ ls /usr/bin | tee ls.txt | grep zip 