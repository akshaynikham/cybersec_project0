Shell?1. When we speak of the command line, we are really referring to the shell.2. The shell is a program that takes keyboard commands and passes them to the operating system to carry out.3. Almost all Linux distributions supply a shell program from the GNU Project called bash.Terminal Emulators?When using a graphical user interface (GUI), we need another program called terminal emulators to interact with the SHELL.KDE uses konsole and GNOME uses gnome-terminal, it's likely called simply "terminal" on our menu.---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Navigation -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------pwd - Print name of current working directory.cd - Change directoryls - list directory contents---Understanding the File System Tree---	- Like Windows, a Unix-like operating system such as Linux organizes its files in what is called a hierarchical directory structure.	- The first directory in the tree structure is called the root directory.	- Unix-like systems such as Linux always have a single file system tree, regardless of how many drives or storage devices are attached to the computer.	- Storage devices are attached (or mounted) at various points on the tree.---The current working directory---	- The directory we are standing is called the current working directory.	- To display current working directory we use pwd ( print working directory )	- Ex: 	[me@linuxbox ~]$ pwd		/home/me	- When we log in to our system ( or start a terminal session ) our current working directory is set to our home directory.	- Each user is given its own home directory and it is the only place a regular user is allowed to write files.---Listing the contents of a Directory---	- To the content of the files and directory, we use ls command.	- Ex: 	[me@linuxbox ~]$ ls 		Desktop Documents Music Pictures Public Templates Videos---Changing the current working Directory---- Absolute Pathnames- Relative Pathnames	---	Absolute Pathnames	---	- An absolute pathname begins by the root directory and follows the tree branch by branch until the path to the desired directory or file is complete.	- Ex: 	[me@linuxbox ~]$ cd /usr/bin		[me@linuxbox bin]$ pwd		/usr/bin		---	Relative Pathnames	---	- As absolute pathname starts from root directory and leads to its destination, a relative pathname starts from the working directory.	- It uses special notations such as "." (dot) and ".." (dot dot).	- The . notation refers to working directory and .. refers to working directory's parent directory.	- Ex:	[me@linuxbox bin]$ cd ..		[me@linuxbox usr]$ pwd		/usr	- Ex:	[me@linuxbox usr]$ cd ./bin		[me@linuxbox bin]$ pwd		/usr/bin------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Exploring the file system -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------ls - list directory contentsfile - Determine file typeless - view file contents	---	Options and arguments	---	- command are often followed by one or more options that modify their behaviour and further by one or more arguments, 		the items upon which the command acts	- command -options arguments	- most commands use options which consists of a single character preceded by a dash, ex, "-l"	- Ex: 	[me@linuxbox ~]$ ls -lt	- Many commands support long options, consisting of a word preceded by two dashes	- Ex: 	[me@linuxbox ~]$ ls -lt --reverse	- The most common ls options		Table 3- 1: Common ls Options		Option 		Long 		Option Description		-a 		--all 		List all files, even those with names that begin with a period, which are normally not listed (that is, hidden).		-A 		--almost-all 	Like the -a option above except it does not list . (current directory) and .. (parent directory).		-d 		--directory 	Ordinarily, if a directory is specified, ls will list the contents of the directory, not the 						directory itself. Use this option in conjunction with the -l option to see details about the 						directory rather than its contents.		-F 		--classify 	This option will append an indicator character to the end of each listed name. For example, a 						forward slash (/) if the name is a directory.		-h 		--human-readable In long format listings, display file sizes in human readable format rather than in bytes.		-l 				Display results in long format.		-r 		--reverse Display the results in reverse order. Normally, ls displays its results in ascending alphabetical order.		-S 				Sort results by file size.		-t 				Sort by modification time.		---	A Longer Look at Long Format	---	- a long format provides a great deal or info	- consider this --> -rw-r--r-- 1 root root 3576296 2017-04-03 11:05 ubuntu.ogg	- -rw-r--r--  	--> 	Access rights to the file. 				The first character indicates the type of file. A leading means a regular file while a "d" indicates a directory.				The next three character indicates access rights for the file owner.				the next three character indicates access right for the members of the file's group.				the final three for everyone else.	- 1 		-->	File's number on hard links.	- root		-->	the user name of the file owner	- root 		-->	the name of the group the owns the file.	- 3576296	--> 	size of the file in bytes.	- 2017-04-03 11:05 -->	The date and time of file's last modification.	- ubuntu.ogg	--> 	name of the file.					---	Determining the file type with file	---	- We use file command to determine the file's type.	- syntax: file filename	- When invoked, the file command will print a brief description of the file's contents.	- Ex: 	[me@linuxbox ~]$ file picture.jpg		picture.jpg: JPEG image data, JFIF standard 1.01	---	viewing file contents with less	--- 	- the less command is a program to view text files.	- The less command is used like this: less filename------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Manipulating Files and Directories --------------------------------------------------------------------------------------------------------------------------------------------------------------------- Wildcards: shell feature. using wildcards, also known as globbing. 	- helps to select filenames based on characters. 	- Wildcard table: 		- * --> matches any characters. 		- ? --> matches a single characters. 		- [characters] --> matches any character that is a member of set characters. 		- [!characters] or [^characters] --> Matches any character that is not a member of the set characters. 		- [[:class:]] --> Matches any characters that is a member of the specified class. 	- commonly used character classes 		- [:alnum:] --> Matches any alphanumerical characters. 		- [:alpha:] --> Matches any alphabetic character. 		- [:digit:] --> Matches any numeral 		- [:lower:] --> Matches any lowercase letter. 		- [:upper:] --> Matched any uppercase letter.---- mkdir: Create directories.---- cp: Copy files and directories. 	- cp can be used in 2 different ways. 		- cp item1 or item2 --> copy file or directory item1 to the file or directory item2 		- cp item... directory --> copies multiple items (either files or directories) into a directory. 	- Useful cp options. 		- -a --archive  	Copy the files and directories and all of their attributes, including ownerships and 					permissions. Normally, copies take on the default attributes of the user performing the 					copy. 		- -i --interactive 	Before overwriting the existing file, prompt the user for confirmation. 		- -r --recursive 	Recursively copy directories and their contents. This option (or the -a option) is required when 					copying directories. 		- -u --update 		When copying files from one directory to another, only copy files that either don't exist or 					are newer than the existing corresponding files, in the destination directory. This is useful when 					copying large numbers of files as it skips files that don't need to be copied. 		- -v --verbose 		Display informative messages as the copy is performed.---- mv: move and rename files. 	- Move performs both file moving and file renaming. 	- mv can be used in 2 different ways. 		- mv item1 or item2 --> move file or directory item1 to the file or directory item2 		- mv item... directory --> move multiple items (either files or directories) into directory. 	- Useful cp options. 	- 	-i --interactive 	Before overwriting an existing file, prompt the user for confirmation. If this option is not specified, mv will silently overwrite files. 		- -u --update 		When moving files from one directory to another, only move files that either don't exist, 					or are newer than the existing corresponding files in the destination directory. 		- -v --verbose 		Display informative messages as the move is performed.---- rm: Remove Files and Directories. 	- The rm command is used to remove (delete) files and directories 	- rm item... --> where item is one or more directory.  	- Useful cp options. 		-i --interactive 	Before deleting an existing file, prompt the user for confirmation. If this option is not specified, 					rm will silently delete files. 		-r --recursive 		Recursively delete directories. This means that if a directory being deleted has subdirectories, 					delete them too. To delete a directory, this option must be specified. 		-f --force 		Ignore nonexistent files and do not prompt. This overrides the --interactive option. 		-v --verbose 		Display informative messages as the deletion is performed.---- ln: Create links 	- this command is used to create either hard or symbolic links. 	- it is used in two ways 		- ln file link --> this create a hard link. 		- ln -s item link --> this creates a symbolic link where item is either file or directory. 	- Hard links: 		- Original way of creating links, compared to symbolic links, which are more modern. 		- In Linux/Unix file systems (like ext4, XFS, etc.), files are not stored directly by their names. 		- A file actually consists of data blocks (the contents of the file) and an inode (a data structure that stores metadata like file size, permissions, and pointers to data 			blocks). 		- A hard link is basically a directory entry that maps a file name to an inode. 		- By default, every file has a single hard link that gives the file its name. 		- Hard links have two important limitations: 			1.	A hard link cannot reference a file outside its own file system. This means a link 				cannot reference a file that is not on the same disk partition as the link itself. 			2. 	A hard link may not reference a directory. 	- Symbolic links: 		- Symbolic links were created to overcome the limitations of hard links. 		- Symbolic links work by creating a special type of file that contains a text pointer to the referenced file or directory. 		- In this regard, they operate in much the same way as a Windows shortcut, though of course they predate the Windows feature by many years. ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Working with Commands -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------What Exactly Are Commands? It might be any of the following 	- An executable program: like all those files in /usr/bin. 	- A command built into the shell itself: Bash supports a number of commands internally called shell built-ins. 	- A shell function: Shell functions are miniature shell scripts incorporated into the environment. 	- An alias: Aliases are commands that we can define ourselves, built from other commands.---Identifying commands.--- 	- It is often useful to know exactly which of the four kinds of commands is being used and Linux provides a couple of ways to find out. 	- type: Display a Command's Type 		- The shell builtin that displays the kind of command the shell will execute, given a particular command once. 		- It works like this: type command --> "command" is the command we want to examine. 	- which: Display an Executable's Location 		- Sometimes there is more than one version of an executable program installed on a system. To determine the exact location of a given executable, 		  the which command is used. 		- ex: 	[me@linuxbox ~]$ which ls 			/usr/bin/ls 		- Imp: which only for executable programs, not bulletins nor alias that are substitutes for actual executable programs.---Getting the command's Documentation--- 	- help: get help for shell builtins 		- bash has built-in facility available for each of the shell builtins. 		- ex: 	[me@linuxbox ~]$ help cd 			cd: cd [-L|[-P [-e]] [-@]] [dir] 			Change the shell working directory. 			Change the current directory to DIR. The default DIR is the 			value of the HOME shell variable. 			The variable CDPATH defines the search path for the directory 			containing DIR. Alternative directory names in CDPATH are 			separated by a colon (:). A null directory name is the same as 			the current directory. If DIR begins with a slash (/), then 			CDPATH is not used. 			If the directory is not found, and the shell option `cdable_vars' 			is set, the word is assumed to be a variable name. If that 			variable has a value, its value is used for DIR. 			Options: 				-L force symbolic links to be followed: resolve symbolic 				links in DIR after processing instances of `..' 				-P use the physical directory structure without following 				symbolic links: resolve symbolic links in DIR before 				processing instances of `..' 				-e if the -P option is supplied, and the current working 				directory cannot be determined successfully, exit with 				a non-zero status 				-@ on systems that support it, present a file with extended 				 attributes as a directory containing the file attributes 				 The default is to follow symbolic links, as if `-L' were 				 specified. `..' is processed by removing the immediately previous 				 pathname component back to a slash or the beginning of DIR. 				 Exit Status: 					 Returns 0 if the directory is changed, and if $PWD is set 					 successfully when -P is used; non-zero otherwise. 		- A note on notation:   When square brackets appear in the description of a command's syntax, 					they indicate optional items. A vertical bar character indicates mutually exclusive 					items. 					In the case of the cd command above: cd [-L|[-P[-e]]] [dir] 					This notation says that the command cd may be followed optionally by either a “-L” or a 					“-P” and further, if the “-P” option is specified the “-e” option may also be included followed by the optional argument “dir”. 	- --help -> Display usage information 		    Many executable program support "--help" option that displays a description of the command's supported syntax and options. 		    -ex: [me@linuxbox ~]$ mkdir --help 	- man -> Display a program's Manual Page. 		- Most executable program intended for command line use provide a formal piece of documentation called manual or man page. 		- A special paging program called man is used to view them. 		- syntax: man program 	- apropos -> Display Appropriate commands. 			- it is possible to search the list of man pages for possible matches based on a search item. 			- ex: 	[me@linuxbox ~]$ apropos partition 				output -> addpart(8) 		- simple wrapper around the "add partition"... 				explanation -> first field is the name of the man page, second field shows the section. 			- Note: man command the "-k" option performs the same function as apropos. 	- whatis -> Display one-line manual page description. 			- whatis program displays the name and a one-line description of a man page matching a specific keyword. 			- ex: 	[me@linuxbox ~]$ whatis ls 				ls (1) - list directory contents  	- info -> The GNU Project provides an alternative to man pages for their programs, called “info.” 		  Info manuals are displayed with a reader program named, appropriately enough, info. 		  Info pages are hyperlinked much like web pages.---- Creating our own command---- 	- syntax: alias name='string'	- After the command alias, we give alias a name followed immediately (no whitespace	  allowed) by an equal sign, followed immediately by a quoted string containing the meaning to be assigned to the name.	- Ex: [me@linuxbox ~]$ alias foo='cd /usr; ls; cd -'	- To remove an alias, the unalias command is used, like so: [me@linuxbox ~]$ unalias foo	- To see all the aliases defined in the environment, use the alias command without arguments.----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Redirection ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Introduce the following commands,1. cat - concatenate files2. sort - sort lines of text3. uniq - Report or omit repeated lines4. grep - Print lines matching a pattern5. wc - print newline, word and byte counts for each file6. head - Output the first part of a file7. tail - output the last part of a file8. tee - Read from standard input and write to standard output and files---Standard input, output and error---	- Keeping with the Unix theme that "everything is a file" programs such as ls send their results to a special file called standard output (often expressed as stdout)	  and their status message to standard error (stderr).	- By default, both stdout and stderr are linked to screen and not saved to file.	- many programs take input from a facility called standard input (stdin), which is by default attached to the keyboard.	- Standard error messages are sent to standard error ( stderr ).	- with I/O redirection we can change where the input comes and output goes.---Redirecting the standard output---	- To redirect standard output to another file instead of the screen, we use > redirection operator followed by the name of the file.	- Ex: [me@linuxbox ~]$ ls -l /usr/bin > ls-output.txt	- Note: when redirect operator is used ">" the destination file always overwritten.	- To redirect output without overwriting the file we need to use ">>" 	- Ex: [me@linuxbox ~]$ ls -l /usr/bin >> ls-output.txt---Group Commands---	- Scenario: imagine a situation where we want to execute a series of commands and send the results to a log file. 	- we can try this [me@linuxbox ~]$ command1; command2; command3	- Ex: [me@linuxbox ~]$ command1 > logfile.txt; command2 >> logfile.txt; command3 >> logfile.txt	- but we can also do this by creating a group command: [me@linuxbox ~]$ { command1; command2; command3; } > logfile.txt---Redirecting Standard Error---	- Redirecting standard error lacks the ease of a dedicated redirection operator.	- we referred first three file stream as standard input, output and error, the shell refer to them internally as file descriptor 0,1,2 respectively.	- shell provides a notation for redirecting file using file descriptor.	- since standard error is same as file descriptor number 2, we can redirect standard error as with the notation as 		[me@linuxbox ~]$ ls -l /bin/usr 2> ls-error.txt				---Redirecting standard output and standard error to one file---	- there are two ways to do it: 		1. [me@linuxbox ~]$ ls -l /bin/usr > ls-output.txt 2>&1		2. [me@linuxbox ~]$ ls -l /bin/usr &> ls-output.txt	- We can also append the standard output and standard error streams to a single file like so:		[me@linuxbox ~]$ ls -l /bin/usr &>> ls-output.txt---Disposing of unwanted output---	- We can throw away the output to a special file called "dev/null"	- the file is a system device often referred to as bit bucket, which accepts input and does nothing with it.---Redirecting the standard input---		cat - concatenate files	-----------------------	- the cat command reads one or more files and copies them to standard output like: cat [file...]	- cat is often used to display short files.	- since cat accepts more than one file as an argument, it can also be used to join files together.	- if cat is not given any arguments, it reads from standard input and since standard input is by default attached to the keyboard, 	  it will wait for user input. ctl-d to tell cat it has reached end of the file.	- cat copies standard input to standard output, this behaviour can be used to create short text files.	- Ex: 	[me@linuxbox ~]$ cat > lazy_dog.txt		The quick brown fox jumps over the lazy dog.	- In the above example, cat will accept the user input and place the input into the file. If the file does not exists the > operator will create one.	- To see our results, we can use cat to copy the file to stdout again.	- Ex: 	[me@linuxbox ~]$ cat lazy_dog.txt		The quick brown fox jumps over the lazy dog.	- we can redirecting standard input to cat as shown: 		[me@linuxbox ~]$ cat < lazy_dog.txt 		The quick brown fox jumps over the lazy dog.	- Using the "<" redirection operator we can change the source from standard input from the keyboard to the file lazy_dog.txt	Pipeline	-----------------------	- The capability of commands to read data from standard input and send to standard output is utilized by a shell feature called pipelines.	- Using the pipe operator | (vertical bar), the standard output of one command can be piped into standard input of another.	- command1 | command2		Filters		-----------------------		- Sort		Uniq - report or Omit repeated lines		-----------------------		- The uniq command is used in conjunction with sort.		- uniq accepts a sorted list of data either from standard input or a single filename argument and by default removes any duplicates from the list.		- Ex: [me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | less		- If we want to see the list of duplicates instead, we add the “-d” option to uniq like so:		- Ex: [me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq -d | less		wc - Print line, word and byte count		-----------------------		- The wc (word count) command is used to display the number of lines, words, and bytes contained in a files.		- Ex: 	[me@linuxbox ~]$ wc ls-output.txt 			7902 64566 503634 ls-output		- it prints lines, count and byte counts		- Like previous commands, if executed without a command line arguments, wc accepts standard input.		grep - Print lines matching a pattern		-----------------------		- grep is a powerful program used to find text pattern within the files. It's used like this,		- syntax: grep pattern [file...]		- when grep encounters a "pattern" in the file, it prints out the lines containing it.		- Ex: 	[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | grep zip			bunzip2			bzip2			gunzip			gzip			unzip			zip			zipcloak			zipgrep			zipinfo			zipnote			zipsplit		- few handy options for grep			-i, causes grep to ignore case when performing the search			-l, causes grep to only output the names of the files containing text that matches the pattern.			-v, causes grep to print only lines that do not match the pattern.			-w, caused grep to only match whole words. 		head/tail - Print First/Last Part of files		-----------------------		- head prints the first ten lines and tails command prints the last ten lines.		- Ex:	[me@linuxbox ~]$ head -n 5 ls-output.txt			total 343496			-rwxr-xr-x 1 root root 31316 2007-12-05 08:58 [			-rwxr-xr-x 1 root root 8240 2007-12-09 13:39 411toppm			-rwxr-xr-x 1 root root 111276 2007-11-26 14:27 a2p			-rwxr-xr-x 1 root root 25368 2006-10-06 20:16 a52dec			[me@linuxbox ~]$ tail -n 5 ls-output.txt			-rwxr-xr-x 1 root root 5234 2007-06-27 10:56 znew			-rwxr-xr-x 1 root root 691 2005-09-10 04:21 zonetab2pot.py			-rw-r--r-- 1 root root 930 2007-11-01 12:23 zonetab2pot.pyc			-rw-r--r-- 1 root root 930 2007-11-01 12:23 zonetab2pot.pyo			lrwxrwxrwx 1 root root 6 2016-01-31 05:22 zsoelim -> soelims				- These commands can be used in pipelines as well:		- Ex: [me@linuxbox ~]$ ls /usr/bin | tail -n 5		- "-n" options with head and tail allow us to cut an excerpt from the middle of the file.		- The -n option when used with head allows a negative value which causes all but the last n lines to be output. 			Similarly, the -n option with tail allows a plus sign causing all but the first n lines to be output. 				tee - Read from Stdin and Output to Stdout and Files		-----------------------		- Linux provides a command called tee which creates a "tee" fitting on our pipe.		- The tee program reads standard input and copies to standard out ( allowing the data to continue down the pipeline) and to one or more files.		- Ex: [me@linuxbox ~]$ ls /usr/bin | tee ls.txt | grep zip--------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Seeing the world as shell sees it -------------------------------------------------------------------------------------------------------------------------------------------------------------------------echo – Display a line of text---Expansion---- Each time we type a command and press enter key, bash performs several substitution upon the text before it carries out our command.- The process is called expansion.- Ex: 	[me@linuxbox ~]$ echo *	Desktop Documents ls-output.txt Music Pictures Public Templates Videos- Explanation: 	Here the command should have printed * but it didn't. This is because when the Enter key is pressed, the shell automatically expands the qualifying		before the command is carried out, so the echo command never saw the *, only it's extended result. 	---	Pathname Expansion	---	- The mechanism by which wildcards work is called pathname expansion.	- Given a home directory looks lik this,		[me@linuxbox ~]$ ls		Desktop ls-output.txt Pictures Templates Documents Music Public Videos	- we can apply the expansion as:		ex1: 	[me@linuxbox ~]$ echo D*			Desktop Documents			ex2:	[me@linuxbox ~]$ echo *s			Documents Pictures Templates Videos		ex3:	[me@linuxbox ~]$ echo [[:upper:]]*			Desktop Documents Music Pictures Public Templates Videos		---	Tilde Expansion	---	- the tilde character (~) has a special meaning.	- When used at the beginning of a word, it expands into the name of the home directory of the named user or, if no user is named, the home directory of the current user.	- ex: 	[me@linuxbox ~]$ echo ~		/home/me	---	Arithmetic Expansion	---	- The shell allows arithmetic to be performed by expansion. 	- This allows us to use the shell prompt as a calculator.	- Ex: 	[me@linuxbox ~]$ echo $((2 + 2))		4	- It uses the following form: $((expression))		---	Brace Expansion	---	- Perhaps the strangest expansion is called brace expansion.	- Ex1: 	[me@linuxbox ~]$ echo Front-{A,B,C}-Back		Front-A-Back Front-B-Back Front-C-Back	- Ex2:	[me@linuxbox ~]$ echo Number_{1..5}		Number_1 Number_2 Number_3 Number_4 Number_5		---	Parameter Expansion	---	- It is a feature more powerful in shell scripts rather than the command line.	- Many of its capability has to do with small chunks of data and to give each chunks a name. Many such chunks, more properly called variables.	- For example, the variable USER contains user name. [me@linuxbox ~]$ echo $USER  --> me	- To see a list of available variables, try this: [me@linuxbox ~]$ printenv | less		---	Command Substitution	---	- command substitution allows us to use the output of command as expansion.	- Ex: 	[me@linuxbox ~]$ echo $(ls)		Desktop Documents ls-output.txt Music Pictures Public Templates Videos	- Ex:	[me@linuxbox ~]$ ls -l $(which cp)		-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp	- Entire pipelines can be used Ex: [me@linuxbox ~]$ file $(ls -d /usr/bin/* | grep zip)	- There is an alternate syntax for command substitution used by older shell programs that is also supported in bash. 		It uses backquotes instead of the dollar sign and parentheses. 	- Ex: 	[me@linuxbox ~]$ ls -l `which cp`		-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp---Quoting	---		- Time to learn how to control the expansion.	- Ex:	[me@linuxbox ~]$ echo this is a 	test		this is a test	- Explanation: word-splitting by the shell removed extra whitespace from the echo command's list of arguments.	- Ex: 	[me@linuxbox ~]$ echo The total is $100.00		The total is 00.00	- Explanation: parameter expansion substituted an empty string for the value of $1 because it was an undefined variable.	- Why Quoting?? --> The shell provides a mechanism called quoting to selectively suppress unwanted expansions	---	Double quotes	---	- If we place text inside double quotes, all the special characters used by the shell lose their special meaning and are treated as ordinary characters	- The exceptions are $, \ (backslash), and ` (back-quote). 	- This means that word-splitting, pathname expansion, tilde expansion, and brace expansion are suppressed,	- But parameter expansion, arithmetic expansion, and command substitution are still carried out.	- Ex: 	[me@linuxbox ~]$ echo "$USER $((2+2)) $(df -h)"	- Ex: 	[me@linuxbox ~]$ echo "this is a 	test"		this is a 	test		---	Single quotes	---	- If we need to suppress all expansions, we use single quotes.	- Here's a comparison of unquoted, double quotes, and single quotes:		[me@linuxbox ~]$ echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER		text /home/me/ls-output.txt a b foo 4 me		[me@linuxbox ~]$ echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"		text ~/*.txt {a,b} foo 4 me		[me@linuxbox ~]$ echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'		text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER		---	Escaping Characters	---	- Sometimes we want to quote only a single character.	- To do this, we can precede a character with a backslash, which in this context is called the escape character.	- Often, this is done inside double quotes to selectively prevent an expansion.	- Ex: 	[me@linuxbox ~]$ echo "The balance for user $USER is: \$5.00"		The balance for user me is: $5.00	- Is is common to use escaping to eliminate special meaning of a character in a file name.	- Ex:	[me@linuxbox ~]$ mv bad\&filename good_filename	- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Advanced Keyboard Tricks ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------clear - Clear the screenhistory - Display the contents of the history list---Command Line Editing---		---	Cursor Movement	---	Key 		Action	Ctrl-a 		Move cursor to the beginning of the line.	Ctrl-e 		Move cursor to the end of the line.	Ctrl-f 		Move cursor forward one character; same as the right arrow key.	Ctrl-b 		Move cursor backward one character; same as the left arrow key.	Alt-f 		Move cursor forward one word.	Alt-b 		Move cursor backward one word.	Ctrl-l 		Clear the screen and move the cursor to the top-left corner. The clear command does the same thing.	---	Modifying Text	---	Key 		Action	Ctrl-d 		Delete the character at the cursor location.	Ctrl-t 		Transpose (exchange) the character at the cursor location with the one preceding it.	Alt-t 		Transpose the word at the cursor location with the one preceding it.	Alt-l		Convert the characters from the cursor location to the end of the word to lowercase.	Alt-u		Convert the characters from the cursor location to the end of the word to uppercase.	---	Cutting and Pasting (Killing and Yanking) Text	---	Key		Action	Ctrl-k		Kill text from the cursor location to the end of line	Ctrl-u		Kill text from the cursor location to the beginning of the line.	Alt-d		Kill text from the cursor location to the end of the current word.	Alt-Backspace	Kill text from the cursor location to the beginning of the current			word. If the cursor is at the beginning of a word, kill the previous word.	Ctrl-y 		Yank text from the kill-ring and insert it at the cursor location.	---	Completion	---	- Another way that the shell can help us is through a mechanism called completion.	- Completion occurs when we press the tab key while typing a command.	Key		Action		---	Using History	---	- bash maintains a history of commands that have been entered. 	- This list is maintained in the home directory in a file called .bash_history		---		Searching history		---		- We can view the contents of history by doing the following, [me@linuxbox ~]$ history | less		- most modern Linux distributions configure bash to store the last 1000 commands we have entered.		- History commands		Key 		Action		Ctrl-p 		Move to the previous history entry. This is the same action as the up arrow.		Ctrl-n 		Move to the next history entry. This is the same action as the down arrow.		Alt-< 		Move to the beginning (top) of the history list.		Alt-> 		Move to the end (bottom) of the history list, i.e., the current command line.		Ctrl-r 		Reverse incremental search. This searches incrementally from the current command line up the history list.		Alt-p 		Reverse search, nonincremental. With this key, type in the search string and press enter before the search is performed.		Alt-n 		Forward search, nonincremental.		Ctrl-o 		Execute the current item in the history list and advance to the next one. This is handy if we are trying to re-execute a sequence of				commands in the history list		---		History Expansion		---		- The shell offer a specialized type of expansion for items in the history list by using the ! character.		sequence 	Action		!! 		Repeat the last command. It is probably easier to press up arrow and enter		!number 	Repeat history list item number.		!string		Repeat last history list item starting with string.		!?string	Repeat last history list item containing string.		---		Script		---		- Most Linux distributions include a program called script		- It can be used to record entire shell session and store it in a file.		- Syntax: Script filename		- if not filename is specified, the file typescript is used.------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ Permissions --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------id 	- Display user identitychmod 	- Change a file's modeunmask	- Set the default file permissionssu	- run a shell as another usersudo	- Execute a command as another userchown	- change the file's ownerchgrp	- change a file's group ownershipaddgroup - add a user or a group to the systemusermod	- modify a user accountpasswd	- change a user's password	---	Users, Group members, and Everybody Else	---	- To find info about our identity, we use id command	- Ex:	[me@linuxbox ~]$ id		uid=500(me) gid=500(me) groups=500(me)	- Ex:	[me@linuxbox ~]$ id		uid=1000(me) gid=1000(me) groups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),108(lpadmin),114(admin),1000(me)	- In Fedora, the uid and gid numbering for regular user account starts at 500 & in Ubuntu it starts from 1000.	- Like so many things in Linux, it comes from a text files. User accounts are defined in the /etc/passwd file and groups are defined in the /etc/group file.	- when users and groups are created, these modified along with /etc/shadow, which holds the info about the user's password.		---	Reading, writing and Executing	---	- Access rights to files and directories are defined in terms of read access, write access and execution access.	- Ex: 	[me@linuxbox ~]$ ls -l foo.txt		-rw-rw-r-- 1 me me 0 2016-03-06 14:52 foo.txt	- The first 10 characters of the listing are file attributes.	- The first of the characters are the file types.		Table file table		Attribute	File type		-		a regular file		d		a directory		l		a symbolic link. For symbolic links, the remaining file attributes are always "rwxrwxrwx" and are dummy values		c		a character special file. The file type refers to a device that handle data as a stream of bytes, such as terminal or /dev/null		b		a block special file. This file type refers to a device that handles data in blocks, such as a hard disk or DVD drive		- The remaining nine characters of the file attributes, called the file mode, represent the read, write and execute permissions for the file's owner		file's group owner and everybody else.	- 	User	Group	others		rwx	rwx	rwx	- Permission Attributes:		Attributes		Files									Directories		r			Allows are file to be opened and read.					Allows a directory content to be listed, but no file info is available 															unless the execute attribute is also set.		w			Allows the file to be written to or truncated, but will not allow	Allows the file within a directory to be created, deleted and renamed if					files to delete or renamed. The ability to delete or rename depends 	the execute attribute is also set.					on directory attribute									x			Allows the file to be treated as a program and executed.		Allows a directory to be entered (i.e., cd directory) and					Program files written in scripting languages must also be set as	directory metadata (i.e, ls -l directory) to be accessed.					readable to be executed.						File operations such cp, rm, and mv require this access to the directory.	---				chmod – Change File Mode	---	- to change the mode (permissions) of a file and directory, the chmod command is used.	- only the file's owner or superuser can change the mode of file or directory.	- chmod supports two distinct ways to specify mode change: Octal number representation and symbolic representation.									- With octal notation, we use octal numbers to set the pattern of desired permission.	- Table 9-4: File Modes in Binary and Octal		Octal Binary File Mode		0 	000 	---		1 	001 	--x		2 	010 	-w-		3 	011 	-wx		4 	100 	r--		5 	101 	r-x		6 	110 	rw-		7 	111 	rwx	- Ex:	[me@linuxbox ~]$ > foo.txt		[me@linuxbox ~]$ ls -l foo.txt		-rw-rw-r-- 1 me me 0 2016-03-06 14:52 foo.txt		[me@linuxbox ~]$ chmod 600 foo.txt		[me@linuxbox ~]$ ls -l foo.txt		-rw------- 1 me me 0 2016-03-06 14:52 foo.txt	- chmod also supports symbolic notation for specifying file mode.	- Symbolic notation is divided into three parts:		- Who the change will affect		- Which operation will be performed		- What permission will be set	- To specify who is affected a combination of characters, "u" "g" "o" "a" is used.	- 	Symbol		Meaning		u		Short for user i.e., the file or directory's owner				g		Group owner		o		Short for others		a		Short for "all". This is a combination of "u" "g" and "o".	- if no characters in specified "all" will be assumed.	- The operation may be a "+" indicating that a permission is to be added, a "-" indicating that a permission is to be take away 		or a "=" indicating that only the specified permission are to be applied and all others to be removed.	- Ex: 	u+x   --> Add execute permission for the owner.		o-rw  --> Remove read and write permission for anyone besides the user and the group owner.	---	umask - user file creation mask	---	- The umask command controls the default permission given to a file when it is created.	- It uses octal notations to express a mask of bits to be removed from file mode attributes.	- Default permission: 		When a file is created the system starts with base permissions of 666 ( read + write for everyone ), no execute by default.		When a directory is created, the system starts with base permission of 777 ( read + write + execute for everyone ) then the unmask value 		is subtracted (bitwise) to get a final permissions.	- suppose if umask is 0002. then 		New files:		start with 666		Subtract 022 → results in 644 (rw-r--r--)		New directories:		Start with 777		Subtract 022 → results in 755 (rwxr-xr-x)	-	Original file mode 	--- rw- rw- rw		Mask 			000 000 010 010		Result 			--- rw- r-- r--		where a 1 appears in the binary value, the corresponding attribute is unset.		---	Changing identities	---	- There are three ways to change identities		1. Log out and log back in as the alternative user.		2. Use the su command		3. Use the sudo command	We will focus on 2 and 3.			--- 		su - Run a Shell with Substitute User and Group IDs		---		- su command allows us to assume the identity of another user and either start a new shell session with that user's ID or			to issue a single command as that user.		- Syntax: su [-[l]] [user]		- If "-l" option is included, the resulting shell session is a login shell for the specified user.		- The user environment is loaded and the working directory is changed to the user's home directory.		- If user is not specified, the superuser is assumed.		- "-l" can also be abbreviated as "-"		- Ex: 	[me@linuxbox ~]$ su -			Password:			[root@linuxbox ~]#		- **It is also possible to execute a single command rather than starting a new interactive command by using the su this way,			su -c "command"		- Ex: 	[me@linuxbox ~]$ su -c 'ls -l /root/*'			Password:			-rw------- 1 root root 754 2007-08-11 03:19 /root/anaconda-ks.cfg		---		sudo - Execute a Command as Another User		---		- sudo command is like su in many ways but has some important capabilities.		- The admin can configure sudo to allow an ordinary user to execute command as a different user (usually superuser) in a controlled way.		- **In particular, a user may be restricted to one or more specific commands and no others.		- **Another important difference is that the use of sudo does not require access to the superuser's password. 			Authenticating using sudo, requires the user’s own password.		- Ex:	[me@linuxbox ~]$ sudo backup_script			Password:			System Backup Starting...		- that sudo can be used to start an interactive superuser session (much like su -) by using the -i option		- To see what privileges are granted by sudo, use the -l option to list them:			[me@linuxbox ~]$ sudo -l			User me may run the following commands on this host:				(ALL) ALL				---		chown - Change file owner and group		---		- chown is used to change the owner and group owner of a file or a directory.		- Superuser privilege are required to use this command.		- Syntax: chown [owner][:[group]] file...		- 	Argument 	Results			bob 		Changes the ownership of the file from its current owner to user bob.			bob:		users Changes the ownership of the file from its current owner to user					bob and changes the file group owner to group users.			:admins 	Changes the group owner to the group admins. The file owner is unchanged.			bob: 		Changes the file owner from the current owner to user bob and					changes the group owner to the login group of user bob.				---		chgrp – Change Group Ownership		---		- In older version of Unix, chown command only changed file ownership, not group ownership.		- For that purpose a separate command, chgrp was used.		---		Changing the Password		---		- To set or change a password, passwd command is used.		- Syntax: passwd [user]		- If we have superuser privileges, then we can specify a username as an argument for passwd command to the set the password for another user.		- ** the passwd, addgroup, and usermod commands are part of a suite of commands in shadow-utils package.		- 	command		Description		  	lastlog		reports most recent login of all users or of a given user.			useradd		create a new user or update default new user information.			usermod		modify a user account							userdel		delete a user account			groupadd	Create a new group			groupdel	delete a group			groupmod	modify a group definition on the system-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Processes --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ps 	- report a snapshot of current processes.top 	- display tasksjobs	- list active jobsbg	- place a job in the backgroundfg	- place a job in the foregroundkill	- send a signal to a processkillall	- kill processes by namenice	- Run a program with modified scheduling priorityrenice	- alter priority of running processesnohup	- run a command immune to hangupshalt/power-off/reboot	- halt,power-off or reboot the system.shutdown - shutdown or reboot the system	---	How a process works	---	- when a system starts up, the kernel initiates a few of it's own activities as processes and launches a program called init.	- init, in turn, starts system which starts all the system services.	- In older Linux distro, init runs a series of shell scripts (located in /etc) called init scripts.	- Many system services are implemented as daemon programs, programs that just sit in the background and do their thing		without having any user interface.	- the kernel maintains info about each process to help keep things organized. Each process is assigned a process ID (PID)	- process ID are assigned in ascending order, with init always getting PID 1.	- The kernel also keeps track of the memory assigned to each process, as well as the processes' readiness to resume execution. 	- Like files, processes also have owners and user IDs, effective user IDs, etc.	---	Viewing the process	---	- one of the most commonly used tool is ps command.	- 	[me@linuxbox ~]$ ps 		PID 	TTY 	TIME 	CMD		5198 	pts/1 00:00:00 bash		10129 	pts/1 00:00:00 ps	- By default only shows processes associated with current terminal session.	- TTY is short for "teletype", refers controlling terminal of the process.	- TIME is the amount of cpu time consumed by the process.	- 	[me@linuxbox ~]$ ps x		PID TTY STAT 	TIME 	COMMAND 		2799 ? 	Ssl 	0:00 /usr/libexec/bonobo-activation-server –ac 		2820 ? 	Sl 	0:01 /usr/libexec/evolution-data-server-1.10 -	- the presence of "?" in TTY column indicates not controlling terminal.	- STAT is short for state		R	Running. This means that the process is running or ready to run.		S	Sleeping. The process is not running; rather, it is waiting for an event, such as a keystroke or network packet.		D	Uninterruptible sleep. The process is waiting for I/O such as a disk drive.		T	Stopped. The process has been instructed to stop.		Z	A defunct or “zombie” process. This is a child process that has terminated but has not been cleaned up by its parent.		<	A high-priority process. It's possible to grant more importance to a process, giving it more time on the CPU. This property of a process			is called niceness. A process with high priority is said to be less nice because it's taking more of the CPU's time, which leaves less for			everybody else.		N	A low-priority process. A process with low priority (a “nice” process) will get processor time only after other processes with			higher priority have been serviced.	- Another popular set of options is “aux” (without a leading dash). This gives us even more information.	- 	[me@linuxbox ~]$ ps aux		USER PID %CPU %MEM VSZ  RSS TTY STAT START TIME COMMAND		root 1   0.0  0.0  2136 644 ?   Ss   Mar05 0:31 init	- This set of options displays the processes belonging to every user.	- The most popular BSD options are		Option 	Function		x 	List our running processes.		ax 	List all running processes..		w 	Include full command names.		u 	Verbose listing.	---	Viewing processes Dynamically with top	---	- ps view machine state at the moment but top shares more dynamic view of the machine's activity.	- it continuously updates, by default every 3 seconds.---Controlling the process---	---	Interrupting a process	---	- Ctrl-c will interrupts a program	---	Putting a process in the background	---	- A program can be placed in background using & 	- Ex: 	[me@linuxbox ~]$ xlogo &		[1] 28236		[me@linuxbox ~]$	- the numbers are shell feature called job control	- it's telling that we created a job number 1 ([1]) and it has PID 28236	- using the jobs command the shell's control facility let us to list jobs launched from our terminal	- we can put multiple commands in background,	- Ex:	me@linuxbox:~$ xlogo & gedit &		[1] 47211		[2] 47212		---	Returning a Process to the Foreground 	---	- we use fg command to bring the program to the foreground	- we can use % followed by the job number (called a jobspec) to do the same.	- Ex:	[me@linuxbox ~]$ jobs		[1]+ Running xlogo &		[me@linuxbox ~]$ fg %1		xlogo	---	Stopping (pausing) a process	---	- we can stop a program without terminating it by using Ctrl-z	- we can either continue the program execution in the foreground, using the fg command or resume the program's execution in the background with the bg command.		---	controlling a process	---	- we can control the priority (niceness) of a program using nice and renice command.	- Only superuser can priority of the process and normal user can only decrease the priority of the process.	- Niceness adjustments are expressed from -20 ( highest priority, least nice) to +19 ( lowest priority, very nice), with a default value 0.	- [me@linuxbox ~]$ sudo nice -n -10 must-run-fast	- 	[me@linuxbox ~]$ ps		PID TTY TIME CMD		379087 pts/9 00:00:00 bash 		379215 pts/9 00:00:00 cpu-hog 		379223 pts/9 00:00:00 ps		[me@linuxbox ~]$ renice -n 19 379215---Signals---	- signals are one of several ways that the operating system communicates with the programs.	---	using kill command to send a signal	---	- earlier we used Ctrl-c and Ctrl-z. when terminal receives these keystrokes, it sends a signal to the program in foreground,		Ctrl-c sent a signal called INT (interrupt) and Ctrl-z sent a signal called TSTP (terminal stop).	- we can send a signal to programs using kill		syntax: kill [-signal] PID...	- If not signal is specified, TERM (terminate) signal is sent by default.	- Some signals are sent to programs and some are sent directly to terminal, like the kill command.	- a complete list of signals can be displayed with the following command: kill -l		---	Making a process Hangup proof	---	- command line programs will respond to the HUP signal by terminating when its controlling terminal "hangs up" (i.e. closes or disconnects).	- to prevent this behaviour, we can launch the program with nohup command. 	- [me@linuxbox ~]$ nohup xlogo	---	Sending Signals to Multiple Processes with killall	---	- It's also possible to send signals to multiple processes matching a specified program or username by using the killall command.	- killall [-u user] [-signal] name...---Shutting Down the System---			- The process of shutting down the system involves the orderly termination of all the processes on the system	- halt, poweroff, reboot and shutdown	- halt, poweroff, reboot - can be used without command line options. [me@linuxbox ~]$ sudo reboot	- shutdown is the general-purpose command that can do all of them. [me@linuxbox ~]$ sudo shutdown -h now--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- The Environment -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- shell maintains a body of information during our shell sessions called environment.- most programs store program settings in configuration files but some programs also look for values in environment to adjust its behaviour.- we will work with following commands,printenvsetexportaliassource---what is stored in the environment---	- shell stores basic two types of data, environment variable and shell variables	- shell variables are bits of data placed there by the current instance of the bash and environment variable are everything else.		--- 	Examining the environment	---	- to see what stored in the env, we can use set command or printenv	- set will show both shell and environment variable 	- printenv will only display env variables	- 	[me@linuxbox ~]$ printenv USER		me	-	[me@linuxbox ~]$ set | less	- also possible to view the contents of a variable using the echo command 		[me@linuxbox ~]$ echo $HOME		/home/me	---	How is the environment established?	---	- when we login bash reads a series of configuration scripts called startup files, which defines environment shared by all users.	- this is followed by more startup files in our home directory that define our personal env.	- the exact sequence depends on the shell session being started,		1. a login shell - A login shell session is the one in which we are prompted for username and password.		2. a non-login shell - A non-login shell session typically occurs when we launch a terminal session in GUI with our terminal session.	- login shell reads one ore more startup files	/etc/profile 	- a global configuration script that applied to all users.	~/.bash_profile	- a user's personal startup file. can be used to extend or override settings in global configuration script	~/.bash_login	- if ~/.bash_profile is not available then bash attempts to read this script	~/.profile	- if neither ~/.bash_profile nor ~/.bash_login is found, bash attempts to read this file		- non-login shell sessions read the startup files. In additional to reading the startup files, non-login shells inherit env variables from parent process.		/etc/bash.bashrc - a global configuration script that applies to all users.	~/.bashrc	 - A user's personal startup file. It can be used to extend or override settings in the global configuration script.	- Personal bin Directory in Linux $HOME is your home directory (e.g., /home/user). 	- By convention, creating a bin folder inside it ($HOME/bin) lets you store personal scripts and programs.	- To make the shell recognize it, add to your PATH: export PATH=$PATH:$HOME/bin	- Now any script placed in ~/bin can be run like a normal command (e.g., myscript) without typing its full path.	- The shell searches directories in PATH in order, so the first match is executed.	---	Exploring how child processes inherit their environments	---	-  a child process cannot alter the environment of its parent. When a child process terminates, it takes its environment with it.	---Modifying the Environment---	---	Which Files Should We Modify?	---	- As a general rule, to add directories to your PATH or define additional environment variables, we need to place the changes in .bash_profile (ubuntu uses .profile)	- for everything else, place the changes in .bashrc	---	Using a Text Editor	---	- Text editors are invoked from the command line by typing the name of the editor followed by the name of the file we want to edit.	- If the file does not already exist, the editor will assume that we want to create a new file.	- Ex:	[me@linuxbox ~]$ gedit some_file		---	Activating our changes 	---	- changes made to .bashrc file will only take effect until we close our terminal session and start a new one. 	- because .bashrc is only read at the beginning of a session.	- we can force bash to reread the modified .bashrc file with the following command: [me@linuxbox ~]$ source ~/.bashrc	- The source command (which can be abbreviated as .) is a shell builtin that reads a file directly into the current shell----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- A Gentle Introduction to vi(m) --------------------------------------------------------------------------------------------------------------------------------------------------------------------------